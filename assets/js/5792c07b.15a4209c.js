"use strict";(self.webpackChunkphoton_website=self.webpackChunkphoton_website||[]).push([[7304],{1132:(e,t,n)=>{n.d(t,{A:()=>i});const i=n.p+"assets/images/socket-3add167a9a0f106df31ac4fef157278f.png"},5680:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>m});var i=n(6540);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=i.createContext({}),s=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=s(e.components);return i.createElement(c.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},g=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=s(n),g=o,m=p["".concat(c,".").concat(g)]||p[g]||u[g]||r;return n?i.createElement(m,a(a({ref:t},d),{},{components:n})):i.createElement(m,a({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,a=new Array(r);a[0]=g;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l[p]="string"==typeof e?e:o,a[1]=l;for(var s=2;s<r;s++)a[s]=n[s];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}g.displayName="MDXCreateElement"},9155:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var i=n(8168),o=(n(6540),n(5680));const r={sidebar_position:6,toc_max_heading_level:4},a="Network",l={unversionedId:"api/network",id:"api/network",title:"Network",description:"Namespace",source:"@site/docs/api/network.md",sourceDirName:"api",slug:"/api/network",permalink:"/docs/api/network",draft:!1,editUrl:"https://github.com/alibaba/PhotonLibOS/edit/main/doc/docs/api/network.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6,toc_max_heading_level:4},sidebar:"docSidebar",previous:{title:"Filesystem and IO",permalink:"/docs/api/filesystem-and-io"},next:{title:"std-compatible API",permalink:"/docs/api/std-compatible-api"}},c={},s=[{value:"Namespace",id:"namespace",level:3},{value:"Headers",id:"headers",level:3},{value:"Socket Encapsulation",id:"socket-encapsulation",level:3},{value:"Brief introduction",id:"brief-introduction",level:4},{value:"ISocketClient",id:"isocketclient",level:4},{value:"ISocketServer",id:"isocketserver",level:4},{value:"ISocketStream",id:"isocketstream",level:4},{value:"Socket class hierarchy",id:"socket-class-hierarchy",level:4},{value:"Socket Implementations",id:"socket-implementations",level:3},{value:"General TCP",id:"general-tcp",level:4},{value:"UDS",id:"uds",level:4},{value:"io_uring",id:"io_uring",level:4},{value:"zerocopy",id:"zerocopy",level:4},{value:"Edge-Trigger",id:"edge-trigger",level:4},{value:"SMC",id:"smc",level:4},{value:"F-Stack + DPDK",id:"f-stack--dpdk",level:4},{value:"IP address and Endpoint",id:"ip-address-and-endpoint",level:3},{value:"IPAddr",id:"ipaddr",level:4},{value:"Endpoint",id:"endpoint",level:4},{value:"HTTP",id:"http",level:3},{value:"libcurl",id:"libcurl",level:4},{value:"Initialization",id:"initialization",level:5},{value:"Headers",id:"headers-1",level:5},{value:"Usage",id:"usage",level:5},{value:"Fs encapsulation",id:"fs-encapsulation",level:5},{value:"Photon HTTP",id:"photon-http",level:4},{value:"\u5934\u6587\u4ef6",id:"\u5934\u6587\u4ef6",level:5},{value:"\u4f7f\u7528",id:"\u4f7f\u7528",level:5},{value:"\u5c01\u88c5",id:"\u5c01\u88c5",level:5}],d={toc:s},p="wrapper";function u({components:e,...t}){return(0,o.yg)(p,(0,i.A)({},d,t,{components:e,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"network"},"Network"),(0,o.yg)("h3",{id:"namespace"},"Namespace"),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"photon::net::")),(0,o.yg)("h3",{id:"headers"},"Headers"),(0,o.yg)("p",null,(0,o.yg)("inlineCode",{parentName:"p"},"<photon/net/socket.h>")),(0,o.yg)("h3",{id:"socket-encapsulation"},"Socket Encapsulation"),(0,o.yg)("h4",{id:"brief-introduction"},"Brief introduction"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Photon abstracts Socket into three interfaces: ",(0,o.yg)("inlineCode",{parentName:"li"},"ISocketClient"),", ",(0,o.yg)("inlineCode",{parentName:"li"},"ISocketServer"),", and ",(0,o.yg)("inlineCode",{parentName:"li"},"ISocketStream")),(0,o.yg)("li",{parentName:"ul"},"Photon Socket supports both IPv4 and IPv6"),(0,o.yg)("li",{parentName:"ul"},"All Socket implementations are non-blocking")),(0,o.yg)("h4",{id:"isocketclient"},"ISocketClient"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"ISocketClient")," only has the connect method, but can connect to multiple protocols, such as TCP, UDP, Unix Domain Socket, etc.")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"class ISocketClient : public ISocketBase, public Object {\npublic:\n    // Connect to a remote endpoint.\n    // If `local` endpoint is not empty, its address will be bind to the socket before connecting to the `remote`.\n    virtual ISocketStream* connect(const EndPoint& remote, const EndPoint* local = nullptr) = 0;\n    // Connect to a Unix Domain Socket.\n    virtual ISocketStream* connect(const char* path, size_t count = 0) = 0;\n};\n")),(0,o.yg)("h4",{id:"isocketserver"},"ISocketServer"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"ISocketServer")," has a series of methods such as bind, listen and accept, as well as methods for starting and terminating loop.\nThe callback function is used to specify the entry for all connections. "),(0,o.yg)("li",{parentName:"ul"},"A successful accept will return an ",(0,o.yg)("inlineCode",{parentName:"li"},"ISocketStream")," pointer; the only parameter of the callback function is also this pointer.")),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"class ISocketServer : public ISocketBase, public ISocketName, public Object {\npublic:\n    virtual int bind(const EndPoint& ep) = 0;\n    virtual int bind(const char* path, size_t count) = 0;\n    int bind(uint16_t port, IPAddr a);\n    // ...\n\n    virtual int listen(int backlog = 1024) = 0;\n    virtual ISocketStream* accept(EndPoint* remote_endpoint = nullptr) = 0;\n\n    using Handler = Callback<ISocketStream*>;\n    virtual ISocketServer* set_handler(Handler handler) = 0;\n    virtual int start_loop(bool block = false) = 0;\n    \n    // Close the listening fd. It's the user's responsibility to close the active connections.\n    virtual void terminate() = 0;\n};\n")),(0,o.yg)("h4",{id:"isocketstream"},"ISocketStream"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},"There are two interfaces of ",(0,o.yg)("inlineCode",{parentName:"p"},"ISocketStream"),", one is send/recv and the other is read/write.")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},"The former is equivalent to libc's send/recv for non-blocking fd. The number of bytes it sent or received may be less than the specified count.\nHowever, the latter is an encapsulation of the former, and it requires the bytes to be exactly equal to count when function returns.\nSo essentially, read is equivalent to fully_recv and write is equivalent to fully_send.")),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("p",{parentName:"li"},"In addition, a corresponding io-vector version has been provided for these two interfaces, same to libc's sendmsg and recvmsg."))),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"class ISocketStream : public IStream, public ISocketBase, public ISocketName {\npublic:\n    virtual ssize_t recv(void *buf, size_t count, int flags = 0) = 0;\n    virtual ssize_t recv(const struct iovec *iov, int iovcnt, int flags = 0) = 0;\n    \n    virtual ssize_t send(const void *buf, size_t count, int flags = 0) = 0;\n    virtual ssize_t send(const struct iovec *iov, int iovcnt, int flags = 0) = 0;\n    \n    virtual ssize_t read(void *buf, size_t count) = 0;\n    virtual ssize_t readv(const struct iovec *iov, int iovcnt) = 0;\n    \n    virtual ssize_t write(const void *buf, size_t count) = 0;\n    virtual ssize_t writev(const struct iovec *iov, int iovcnt) = 0;\n};\n")),(0,o.yg)("h4",{id:"socket-class-hierarchy"},"Socket class hierarchy"),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"socket",src:n(1132).A,width:"1920",height:"1080"})),(0,o.yg)("h3",{id:"socket-implementations"},"Socket Implementations"),(0,o.yg)("h4",{id:"general-tcp"},"General TCP"),(0,o.yg)("p",null,"This is the most commonly used combination of TCP sockets"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"ISocketClient* new_tcp_socket_client();\nISocketServer* new_tcp_socket_server();\n")),(0,o.yg)("h4",{id:"uds"},"UDS"),(0,o.yg)("p",null,"The autoremove parameter indicates whether the UDS file should be automatically deleted when the server is shut down."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"ISocketClient* new_uds_client();\nISocketServer* new_uds_server(bool autoremove = false);\n")),(0,o.yg)("h4",{id:"io_uring"},"io_uring"),(0,o.yg)("p",null,"This group of clients/servers uses the native io_uring IO instead of libc's send/recv.\nWhat's more, its socket fd is not non-blocking."),(0,o.yg)("p",null,"In the scenario of large connections and small traffic (we call it Ping-pong), the io_uring socket should be used first.\nHowever, for large traffic (we call it Streaming), the common TCP socket should be used first.\nFor details, please refer to the network performance test."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"ISocketClient* new_iouring_tcp_client();\nISocketServer* new_iouring_tcp_server();\n")),(0,o.yg)("h4",{id:"zerocopy"},"zerocopy"),(0,o.yg)("p",null,"The TCP zerocopy send relies on kernel 4.15 or above and can reduce CPU workload. It works better for large buffers."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"ISocketClient* new_zerocopy_tcp_client();\nISocketServer* new_zerocopy_tcp_server();\n")),(0,o.yg)("h4",{id:"edge-trigger"},"Edge-Trigger"),(0,o.yg)("p",null,"Edge-triggered TCP socket implementation."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"ISocketClient* new_et_tcp_socket_client();\nISocketServer* new_et_tcp_socket_server();\n")),(0,o.yg)("h4",{id:"smc"},"SMC"),(0,o.yg)("p",null,"RDMA implementation based on ",(0,o.yg)("a",{parentName:"p",href:"https://www.ibm.com/docs/en/aix/7.2?topic=access-shared-memory-communications-over-rdma-smc-r"},"SMC-R")," protocol."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"ISocketClient* new_smc_socket_client();\nISocketServer* new_smc_socket_server();\n")),(0,o.yg)("h4",{id:"f-stack--dpdk"},"F-Stack + DPDK"),(0,o.yg)("p",null,"Coroutine network running with DPDK polling mode. The underlying library is F-Stack (FreeBSD + UserSpace)"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre"},"ISocketClient* new_fstack_dpdk_socket_client();\nISocketServer* new_fstack_dpdk_socket_server();\n")),(0,o.yg)("h3",{id:"ip-address-and-endpoint"},"IP address and Endpoint"),(0,o.yg)("p",null,"The main classes ares ",(0,o.yg)("inlineCode",{parentName:"p"},"IPAddr")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"Endpoint"),". The latter equals to the first plus port number."),(0,o.yg)("h4",{id:"ipaddr"},"IPAddr"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"struct IPAddr {\n    // For compatibility, the default constructor is 0.0.0.0 (IPv4 Any)\n    IPAddr();\n    // V6 constructor (Internet Address)\n    explicit IPAddr(in6_addr internet_addr);\n    // V6 constructor (Network byte order)\n    IPAddr(uint32_t nl1, uint32_t nl2, uint32_t nl3, uint32_t nl4);\n    // V4 constructor (Internet Address)\n    explicit IPAddr(in_addr internet_addr);\n    // V4 constructor (Network byte order)\n    explicit IPAddr(uint32_t nl);\n    // String constructor\n    explicit IPAddr(const char* s);\n    // Check if it's actually an IPv4 address mapped in IPV6\n    bool is_ipv4();\n    // Default addr is IPv4 0.0.0.0, and we regard it as undefined\n    bool undefined();\n    // Should ONLY be used for IPv4 address\n    uint32_t to_nl() const;\n    bool is_loopback() const;\n    bool is_broadcast() const;\n    bool is_link_local() const;\n    \n    static IPAddr V6None();\n    static IPAddr V6Any();\n    static IPAddr V6Loopback();\n    static IPAddr V4Broadcast();\n    static IPAddr V4Any();\n    static IPAddr V4Loopback();\n};\n")),(0,o.yg)("h4",{id:"endpoint"},"Endpoint"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"struct EndPoint {\n    EndPoint() = default;\n    EndPoint(IPAddr ip, uint16_t port) : addr(ip), port(port) {}\n    explicit EndPoint(const char* ep);\n    EndPoint(const char* ip, uint16_t port) : addr(ip), port(port) {}\n    bool is_ipv4() const;\n    // Default endpoint is 0.0.0.0:0\uff0cand we regard it as undefined\n    bool undefined();\n};\n")),(0,o.yg)("admonition",{type:"tip"},(0,o.yg)("p",{parentName:"admonition"},"A server listens to ",(0,o.yg)("inlineCode",{parentName:"p"},"::0")," can serve both IPv4 and IPv6 clients at the same time.")),(0,o.yg)("h3",{id:"http"},"HTTP"),(0,o.yg)("p",null,"Photon has two HTTP components, one is an asynchronous framework based on libcurl + coroutine (only client),\nand the other is a self-developed lightweight HTTP client/server (hereinafter referred to as Photon HTTP)."),(0,o.yg)("h4",{id:"libcurl"},"libcurl"),(0,o.yg)("h5",{id:"initialization"},"Initialization"),(0,o.yg)("p",null,"You need to add libcurl as an IO_ENGINE when calling photon's init."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"photon::init(INIT_EVENT_DEFAULT, INIT_IO_LIBCURL);\n")),(0,o.yg)("h5",{id:"headers-1"},"Headers"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"#include <photon/net/curl.h>\n")),(0,o.yg)("h5",{id:"usage"},"Usage"),(0,o.yg)("p",null,"You need to create a new net::cURL() object for each request, and then call its GET/POST methods."),(0,o.yg)("h5",{id:"fs-encapsulation"},"Fs encapsulation"),(0,o.yg)("p",null,"In ",(0,o.yg)("inlineCode",{parentName:"p"},"<photon/fs/httpfs/httpfs.h>"),", we have implemented a httpfs that has the POSIX compatible read/write interfaces, and did some encapsulation of HTTP headers, status codes, etc."),(0,o.yg)("h4",{id:"photon-http"},"Photon HTTP"),(0,o.yg)("p",null,"There are no third-party dependencies of the self-developed Photon HTTP framework, and it does not require additional IO_ENGINE during init."),(0,o.yg)("h5",{id:"\u5934\u6587\u4ef6"},"\u5934\u6587\u4ef6"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-cpp"},"#include <photon/net/http/client.h>\n#include <photon/net/http/server.h>\n")),(0,o.yg)("h5",{id:"\u4f7f\u7528"},"\u4f7f\u7528"),(0,o.yg)("p",null,"Please refer to ",(0,o.yg)("inlineCode",{parentName:"p"},"net/http/test/client_perf.cpp")," and ",(0,o.yg)("inlineCode",{parentName:"p"},"net/http/test/server_perf.cpp")),(0,o.yg)("h5",{id:"\u5c01\u88c5"},"\u5c01\u88c5"),(0,o.yg)("p",null,"Similarly, we also encapsulated its fs in ",(0,o.yg)("inlineCode",{parentName:"p"},"<photon/fs/httpfs/httpfs.h>"),", which is called httpfs v2."))}u.isMDXComponent=!0}}]);