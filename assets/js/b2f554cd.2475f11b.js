"use strict";(self.webpackChunkphoton_website=self.webpackChunkphoton_website||[]).push([[5894],{6042:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"stackful-coroutine-made-fast","metadata":{"permalink":"/blog/stackful-coroutine-made-fast","editUrl":"https://github.com/alibaba/PhotonLibOS/edit/main/doc/blog/2024-10-14-stackful-coroutine-made-fast.mdx","source":"@site/blog/2024-10-14-stackful-coroutine-made-fast.mdx","title":"Stackful Coroutine Made Fast","description":"Download pdf","date":"2024-10-14T00:00:00.000Z","formattedDate":"October 14, 2024","tags":[],"readingTime":0.04,"hasTruncateMarker":false,"authors":[],"frontMatter":{"slug":"stackful-coroutine-made-fast","title":"Stackful Coroutine Made Fast"},"nextItem":{"title":"How to run Photon on top of DPDK","permalink":"/blog/photon-dpdk"}},"content":"<a href=\\"https://github.com/alibaba/PhotonLibOS/blob/main/doc/static/blog-20241014/Stackful_Coroutine_Made_Fast.pdf\\">\\nDownload pdf</a>\\n\\n<iframe src=\'/blog-20241014/stackful-coroutine-made-fast.html\' width=\\"100%\\" height=\\"30000\\"></iframe>"},{"id":"photon-dpdk","metadata":{"permalink":"/blog/photon-dpdk","editUrl":"https://github.com/alibaba/PhotonLibOS/edit/main/doc/blog/2023-07-29-photon-dpdk.md","source":"@site/blog/2023-07-29-photon-dpdk.md","title":"How to run Photon on top of DPDK","description":"&emsp;&emsp;Since version 0.6, Photon can run on an userspace TCP/IP stack if enabled the INITIOFSTACK_DPDK io engine.","date":"2023-07-29T00:00:00.000Z","formattedDate":"July 29, 2023","tags":[{"label":"DPDK","permalink":"/blog/tags/dpdk"},{"label":"F-Stack","permalink":"/blog/tags/f-stack"}],"readingTime":6.545,"hasTruncateMarker":false,"authors":[{"name":"Bob Chen","title":"Maintainer of PhotonLibOS","url":"https://github.com/beef9999","imageURL":"https://github.com/beef9999.png","key":"beef9999"}],"frontMatter":{"slug":"photon-dpdk","title":"How to run Photon on top of DPDK","authors":["beef9999"],"tags":["DPDK","F-Stack"]},"prevItem":{"title":"Stackful Coroutine Made Fast","permalink":"/blog/stackful-coroutine-made-fast"},"nextItem":{"title":"The thread local variable for coroutines","permalink":"/blog/thread-local"}},"content":"import Tabs from \'@theme/Tabs\';\\nimport TabItem from \'@theme/TabItem\';\\n\\n&emsp;&emsp;Since version 0.6, Photon can run on an userspace TCP/IP stack if enabled the `INIT_IO_FSTACK_DPDK` io engine. \\n\\n&emsp;&emsp;[F-Stack](https://www.f-stack.org/) is an open-source project that has ported the entire **FreeBSD** \\nnetwork stack on top of **DPDK**, and provided userspace sockets and events API. \\nWe have integrated Photon\'s coroutine scheduler with F-Stack, and made a busy-polling program more friendly to DPDK \\ndevelopers than ever before. In terms of performance, the network app has seen the improvement of 20% ~ 40%, compared with\\nthe Linux kernel based on interrupt.\\n\\n&emsp;&emsp;This article will introduce how to configure SR-IOV on a Mellanox NIC, how to set up F-Stack\\nand DPDK environment, how to enable the [Flow Bifurcation](https://doc.dpdk.org/guides/howto/flow_bifurcation.html) \\nto filter the specific TCP/IP flow that you only concern, and finally how to run Photon on top of them, in order \\nto build a high performance net server.\\n\\n### Configure SR-IOV on Mellanox ConnectX-4\\n\\n#### 1. Enable IOMMU\\n\\n```mdx-code-block\\n<Tabs groupId=\\"os\\" queryString>\\n  <TabItem value=\\"CentOS 7\\" label=\\"CentOS 7\\">\\n```\\n\\n```bash\\n# Edit /etc/default/grub\\n# Expand GRUB_CMDLINE_LINUX with \'intel_iommu=on iommu=pt pci=realloc\'\\ngrub2-mkconfig -o /boot/grub2/grub.cfg\\nreboot\\n```\\n\\n```mdx-code-block\\n  </TabItem>\\n  <TabItem value=\\"Debian 10\\" label=\\"Debian 10\\">\\n```\\n\\n```bash\\n# Edit /etc/default/grub\\n# Expand GRUB_CMDLINE_LINUX with \'intel_iommu=on iommu=pt\'\\ngrub-mkconfig -o /boot/grub/grub.cfg\\nreboot\\n```\\n\\n```mdx-code-block\\n  </TabItem>\\n</Tabs>\\n```\\n\\nNote the `pci=realloc` is a work-around solution for CentOS and RHEL.\\nWithout this, kernel would report `not enough MMIO resources for SR-IOV`,\\nsee this [issue](https://access.redhat.com/solutions/37376).\\n\\n#### 2. Set VF number\\n\\n```shell\\necho 4 > /sys/class/net/eth0/device/sriov_numvfs\\n```\\n\\n&emsp;&emsp;If you are having an Intel NIC, this step is likely to succeed. However, for the Mellanox one, \\nit might fail because of the lack of proper mlx driver in your kernel. \\nPlease check the result by typing `lspci -nn | grep Ethernet` and see if the NICs\' virtual function number is correct.\\n\\n&emsp;&emsp;If succeeded, please jump to the part of \'Install DPDK\'.\\n\\n&emsp;&emsp;If failed, you may need to download the official driver from NVidia.\\nThere are many available releases in https://network.nvidia.com/products/infiniband-drivers/linux/mlnx_ofed/,\\nyou should choose one that matches to your kernel version and OS version the best.\\nAn improper version might lead to compiling error when building kernel modules later. \\n\\n- For example, for CentOS 7 and kernel 5.x, you should choose MLNX_OFED_LINUX-5.4-3.6.8.1-rhel7.2-x86_64.tgz\\n- For Debian 10, it is MLNX_OFED_LINUX-5.8-5.1.1.2-debian10.13-x86_64.tgz\\n\\n#### 3. Install mlnx_ofed driver\\n\\n&emsp;&emsp;First you need to check your gcc version. It has to be the same one that built your kernel.\\nOtherwise you will need to upgrade your gcc.\\n\\n```shell\\ngcc --version\\ncat /proc/version\\n```\\n\\n&emsp;&emsp;Note that the NVidia official doc said we should install \'createrepo\', but in CentOS 7, \\nthere are some tiny bugs of its Python scripts. The \'createrepo_c\' package will solve this.\\n\\n```shell\\nyum install python-devel tcl tk elfutils-libelf-devel createrepo_c\\n```\\n\\n&emsp;&emsp;Because the mlnx_ofed driver has already included rdma packages, to avoid collision,\\nI decided to remove all rdma-related rpms previously installed in my test machine.\\n\\n```shell\\nrpm -qa | grep rdma\\nrpm -e ...\\n```\\n\\n&emsp;&emsp;Build and install the driver and the additional packages.\\n\\n```shell\\ncd MLNX_OFED_LINUX-5.4-3.6.8.1-rhel7.2-x86_64/\\n./mlnxofedinstall --skip-distro-check --add-kernel-support --without-mlnx-nvme --dpdk\\n\\n# Update initramfs\\ndracut -f\\n\\n# There will be rdma-core, rdma-core-devel, librdmacm and librdmacm-utils.\\nrpm -qa | grep rdma\\n```\\n\\n&emsp;&emsp;Now we need to restart the server. Be careful, there is a possibility that the interface name\\nof your NIC might change, for example, from `eth0` to something like `enp3s0f0`, where 3 for Bus, 0 for Device,\\nand 0 for Function, represented in the `03:00.0` BDF notation. It will incur connection failure\\nof your server and unable to log in.\\n\\n&emsp;&emsp;To solve this, your first option is to disable the Consistent Interface Device Naming in Linux,\\nand then persist the new names by `udev rules`. See the NVidia docs at\\n[1](https://docs.nvidia.com/networking/display/MLNXOFEDv541030/Changes+and+New+Features#ChangesandNewFeatures-CustomerAffectingChanges),\\n[2](https://enterprise-support.nvidia.com/s/article/howto-change-network-interface-name-in-linux-permanently).\\n\\n1. Append `GRUB_CMDLINE_LINUX` in `/etc/default/grub` with `net.ifnames=0`\\n2. Create the `/etc/udev/rules.d/85-net-persistent-names.rules` with the following content\\n\\n```text\\n# PCI device 15b3:1019 (mlx5_core)\\n# NAME:=\\"some name\\" , := is used to make sure that device name will be persistent.\\nSUBSYSTEM==\\"net\\", ACTION==\\"add\\", DRIVERS==\\"?*\\", ATTR{address}==\\"00:02:c9:fa:c3:50\\", ATTR{dev_id}==\\"0x0\\", ATTR{type}==\\"1\\", KERNEL==\\"eth*\\", NAME:=\\"eth0\\"\\nSUBSYSTEM==\\"net\\", ACTION==\\"add\\", DRIVERS==\\"?*\\", ATTR{address}==\\"00:02:c9:fa:c3:51\\", ATTR{dev_id}==\\"0x0\\", ATTR{type}==\\"1\\", KERNEL==\\"eth*\\", NAME:=\\"eth1\\"\\n```\\n\\n&emsp;&emsp;The second option, if you are OK with the new names, you can update the NIC scripts \\nin `/etc/sysconfig/network-scripts/` and make them correct.\\n\\n&emsp;&emsp;Finally, everything get ready, just reboot:\\n\\n```shell\\nreboot \\n```\\n\\n&emsp;&emsp;After reboot:\\n\\n```shell\\n# Start Mellanox Software Tools Service\\nmst start\\n\\n# Show device name and port mapping\\nmst status\\nibdev2netdev\\n\\n# Check firmware capabilities\\nmlxconfig -d /dev/mst/mt4117_pciconf0 query | grep NUM_OF_VFS\\n\\n# Set VF number. Should succeed now\\necho 4 > /sys/class/net/enp3s0f0/device/sriov_numvfs\\nlspci -nn | grep \'Ethernet controller\'\\n```\\n\\n### Install DPDK\\n\\n&emsp;&emsp;The F-Stack version we choose is [1.22.1](https://github.com/F-Stack/f-stack/releases/tag/v1.22.1), \\nand it has a subdirectory called dpdk that contains the full DPDK 20.11 source code. \\nLet\'s start with the DPDK install first.\\n\\n```mdx-code-block\\n<Tabs groupId=\\"os\\" queryString>\\n  <TabItem value=\\"CentOS 7\\" label=\\"CentOS 7\\">\\n```\\n\\n```bash\\ncd f-stack-1.22.1/dpdk/\\nyum install python3-pip\\nyum install pkg-config numactl-devel zlib-devel ninja\\npip3 install meson \\n```\\n\\n```mdx-code-block\\n  </TabItem>\\n  <TabItem value=\\"Debian 10\\" label=\\"Debian 10\\">\\n```\\n\\n```bash\\ncd f-stack-1.22.1/dpdk/\\npip3 install ninja meson\\napt install pkg-config python3-pyelftools libnuma-dev\\n```\\n\\n```mdx-code-block\\n  </TabItem>\\n</Tabs>\\n```\\n\\nBuild and install:\\n\\n```shell\\nCONFIG_RTE_LIBRTE_MLX5_PMD=y meson -Denable_kmods=true -Dtests=false build\\ncd build\\nninja\\nninja install\\n```\\n\\nAllocate 10GB huge-pages\\n\\n```shell\\necho 5120 > /sys/kernel/mm/hugepages/hugepages-2048kB/nr_hugepages\\n```\\n\\nAttach your PF (with main IP) and one of the VFs (idle) to the poll-mode-driver test\\n\\n```shell\\n./build/app/dpdk-testpmd -l 0-3 -n 4 -a 0000:03:00.0 -a 0000:03:00.2 -- --nb-cores=2 --flow-isolate-all -i -a\\n```\\n\\nNote: The `--flow-isolate-all` option is a MUST do. It enables Flow Bifurcation and ensures that all the\\nundetermined flow will be forwarded to the Linux kernel. Because the default behavior is to drop all packets, so\\nunless you configure the flow table or enable the `--flow-isolate-all` option, \\nyour network connection will be lost again ...\\n\\n### Install F-Stack\\n\\nLet\'s go back to the parent dir and install F-Stack.\\n\\n#### Upgrade pkg-config\\n\\n&emsp;&emsp;The `pkg-config` command in CentOS 7 is of version 0.27.1, and it has a [bug](https://bugs.freedesktop.org/show_bug.cgi?id=56699)\\nthat does not correctly handle gcc\'s `--whole-archive` option.\\nAs per F-Stack\'s document, we can upgrade it to [0.29.2](https://pkg-config.freedesktop.org/releases/pkg-config-0.29.2.tar.gz).\\n\\n&emsp;&emsp;Debian 10 is OK.\\n\\n#### Modify make scripts\\n\\n1. Edit `lib/Makefile`, comment out `DEBUG=...`. We want a release build.\\n2. Edit `lib/Makefile`, enable `FF_FLOW_ISOLATE=1`. It is the trigger of Flow Bifurcation for TCP. The hardcoded TCP port is 80.\\n3. For CentOS 7, edit `mk/kern.mk`, add `-Wno-error=format-overflow` to `CWARNFLAGS`, \\nin case a compiler warning being regarded as error. Debian 10 is OK.\\n\\n#### Build and install\\n\\n```mdx-code-block\\n<Tabs groupId=\\"os\\" queryString>\\n  <TabItem value=\\"CentOS 7\\" label=\\"CentOS 7\\">\\n```\\n\\n```bash\\nexport FF_PATH=/root/f-stack-1.22.1  # Change to your own dir\\nexport REGULAR_PKG_CONFIG_DIR=/usr/lib64/pkgconfig/\\nexport DPDK_PKG_CONFIG_DIR=/usr/local/lib64/pkgconfig/\\nexport PKG_CONFIG_PATH=$(pkg-config --variable=pc_path pkg-config):${REGULAR_PKG_CONFIG_DIR}:${DPDK_PKG_CONFIG_DIR}\\n\\ncd f-stack-1.22/lib\\nmake -j\\nmake install\\n```\\n\\n```mdx-code-block\\n  </TabItem>\\n  <TabItem value=\\"Debian 10\\" label=\\"Debian 10\\">\\n```\\n\\n```bash\\nexport FF_PATH=/root/f-stack-1.22.1  # Change to your own dir\\n\\ncd f-stack-1.22/lib\\nmake -j\\nmake install\\n```\\n\\n```mdx-code-block\\n  </TabItem>\\n</Tabs>\\n```\\n\\n\\n#### Configurations\\n\\n&emsp;&emsp;F-Stack has a global config file at `/etc/f-stack.conf`. We need to make a few changes before running it.\\n\\n1. Change `pkt_tx_delay=100` to `pkt_tx_delay=0`. So it will send packets immediately, rather than wait for a while.\\n2. Modify the `[port0]` section, including `addr`, `netmask`, `broadcast` and `gateway`. Keep the same to your \\ntest machine, because our DPDK app only needs to have a unique TCP port.\\n3. Add `pci_whitelist=03:00.0,03:00.2`. As explained above, the first one is your PF with main IP, the other is one of\\nits idle VFs. The Flow Bifurcation will forward specific TCP flow to VF, while leaving the rest traffic to the PF,\\nfor the Linux kernel.\\n\\n### Run Photon\\n\\n&emsp;&emsp;We have provided a new [example](https://github.com/alibaba/PhotonLibOS/blob/main/examples/fstack-dpdk/fstack-dpdk-demo.cpp).\\nIt looks quite alike the old echo server example, only a few lines of changes, but now the backend becomes DPDK.\\n\\n```shell\\ncd PhotonLibOS\\ngit checkout release/0.8\\ncmake -B build -D PHOTON_BUILD_TESTING=1 -D PHOTON_ENABLE_FSTACK_DPDK=1 -D CMAKE_BUILD_TYPE=Release\\ncmake --build build -j 32 -t fstack-dpdk-demo\\n\\n./build/output/fstack-dpdk-demo\\n```\\n\\nNow you can set up an echo client on another host, and bench this server via port 80."},{"id":"thread-local","metadata":{"permalink":"/blog/thread-local","editUrl":"https://github.com/alibaba/PhotonLibOS/edit/main/doc/blog/2023-07-28-thread-local.md","source":"@site/blog/2023-07-28-thread-local.md","title":"The thread local variable for coroutines","description":"As we all know, C++11 introduced the threadlocal keyword to replace the _thread provided by the compiler,","date":"2023-07-28T00:00:00.000Z","formattedDate":"July 28, 2023","tags":[{"label":"thread-local","permalink":"/blog/tags/thread-local"}],"readingTime":1.115,"hasTruncateMarker":false,"authors":[{"name":"Bob Chen","title":"Maintainer of PhotonLibOS","url":"https://github.com/beef9999","imageURL":"https://github.com/beef9999.png","key":"beef9999"}],"frontMatter":{"slug":"thread-local","title":"The thread local variable for coroutines","authors":["beef9999"],"tags":["thread-local"]},"prevItem":{"title":"How to run Photon on top of DPDK","permalink":"/blog/photon-dpdk"}},"content":"As we all know, C++11 introduced the `thread_local` keyword to replace the `__thread` provided by the compiler,\\nor the `specific key` related functions provided by the `pthread` library.\\n\\nHere is a typical example of using thread_local.\\n\\n```c++\\n#include <thread>\\n\\nstatic thread_local int i = 0;\\n\\nint main() {\\n    auto th = std::thread([]{\\n        i = 1;\\n    });\\n    th.join();\\n    \\n    assert(i == 0);\\n}\\n```\\n\\nPhoton begins to support TLS for coroutines since version 0.4.0. Due to some limitations, Photon cannot achieve the\\nsame syntax as `thread_local`, but implements it in a close way.\\n\\n```c++\\n#include <photon/thread/std-compat.h>\\n\\nstatic photon::thread_local_ptr<int, int> pI(0);\\n\\nint main() {\\n    if (photon::init())\\n        abort();\\n    DEFER(photon::fini());\\n    \\n    auto th = photon_std::thread([]{\\n        *pI = 1;\\n    });\\n    th.join();\\n    \\n    assert(*pI == 0);\\n}\\n```\\n\\nIn this code above, `thread_local_ptr` is a template class that provides pointer-like operators.\\nYou need to pass the appropriate constructor type to its template parameter, which in this example, is also a int.\\n\\nWhen users access it in different coroutines, they will always get a separate value.\\n\\nBelow is a more complicated example:\\n\\n```c++\\nclass Value {\\npublic:\\n    explicit Value(std::string s) : m_s(std::move(s)) {}\\n    size_t size() { return m_s.size(); }\\nprivate:\\n    std::string m_s;\\n};\\n\\nclass A {\\npublic:\\n    void func();\\nprivate:\\n    static photon::thread_local_ptr<Value, std::string> m_value;\\n};\\n\\nstatic photon::thread_local_ptr<Value, std::string> m_value(\\"123\\");\\n\\nvoid A::func() {\\n    std::cout << \\"Value size \\" << m_value->size() << std::endl;\\n}\\n```"}]}')}}]);