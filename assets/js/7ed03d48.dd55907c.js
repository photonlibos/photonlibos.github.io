"use strict";(self.webpackChunkphoton_website=self.webpackChunkphoton_website||[]).push([[7193],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,h=d["".concat(s,".").concat(m)]||d[m]||u[m]||i;return n?o.createElement(h,r(r({ref:t},p),{},{components:n})):o.createElement(h,r({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,r=new Array(i);r[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[d]="string"==typeof e?e:a,r[1]=l;for(var c=2;c<i;c++)r[c]=n[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1297:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var o=n(7462),a=(n(7294),n(3905));const i={sidebar_position:5,toc_max_heading_level:4},r="Write Your First Example",l={unversionedId:"introduction/write-first-example",id:"introduction/write-first-example",title:"Write Your First Example",description:"In this example, we will demonstrate a simple example using various Photon modules,",source:"@site/docs/introduction/write-first-example.md",sourceDirName:"introduction",slug:"/introduction/write-first-example",permalink:"/docs/introduction/write-first-example",draft:!1,editUrl:"https://github.com/alibaba/PhotonLibOS/edit/main/doc/docs/introduction/write-first-example.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,toc_max_heading_level:4},sidebar:"docSidebar",previous:{title:"How to Integrate",permalink:"/docs/introduction/how-to-integrate"},next:{title:"API",permalink:"/docs/category/api"}},s={},c=[{value:"1. Initialize environment",id:"1-initialize-environment",level:3},{value:"2. Create thread",id:"2-create-thread",level:3},{value:"3. Concurrency",id:"3-concurrency",level:3},{value:"4. Lock and synchronization",id:"4-lock-and-synchronization",level:3},{value:"5. File IO",id:"5-file-io",level:3},{value:"6. Socket",id:"6-socket",level:3},{value:"Client",id:"client",level:4},{value:"Server",id:"server",level:4},{value:"Full source code",id:"full-source-code",level:3}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"write-your-first-example"},"Write Your First Example"),(0,a.kt)("p",null,"In this example, we will demonstrate a simple example using various Photon modules,\ni.e., ",(0,a.kt)("inlineCode",{parentName:"p"},"common"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"thread"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"fs"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"io")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"net"),". The program basically set up some Photon threads\nin the background, created a Photon file for IO, and sent buffer through Photon socket.\nPhoton locks and condition viariables are used as well."),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"The example code is written in ",(0,a.kt)("a",{parentName:"p",href:"../api/std-compatible-api"},"std-compatible API"),". "),(0,a.kt)("p",{parentName:"admonition"},"If you want to use the raw API, please refer to this ",(0,a.kt)("a",{parentName:"p",href:"../api/thread"},"doc"),". It can provide more flexible functionalities.")),(0,a.kt)("h3",{id:"1-initialize-environment"},"1. Initialize environment"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"#include <photon/photon.h>\n#include <photon/thread/std-compat.h>\n\nint main() {\n    int ret = photon::init(photon::INIT_EVENT_DEFAULT, photon::INIT_IO_NONE);\n    if (ret != 0) {\n        return -1;\n    }\n    DEFER(photon::fini());\n    // ...\n}\n")),(0,a.kt)("p",null,"After ",(0,a.kt)("inlineCode",{parentName:"p"},"photon::init"),", the ",(0,a.kt)("a",{parentName:"p",href:"../api/env"},(0,a.kt)("strong",{parentName:"a"},"Env"))," is initialized, which means the coroutine stack is successfully allocated on current ",(0,a.kt)("a",{parentName:"p",href:"../api/vcpu-and-multicore"},(0,a.kt)("strong",{parentName:"a"},"vCPU")),". "),(0,a.kt)("p",null,"Now you can create multiple Photon ",(0,a.kt)("a",{parentName:"p",href:"../api/thread"},(0,a.kt)("strong",{parentName:"a"},"threads"))," to run in parallel, or migrate them to other vCPUs."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"photon::fini")," is responsible for deallocating the environment.\nIt's wrapped in a helper macro called ",(0,a.kt)("inlineCode",{parentName:"p"},"DEFER")," from ",(0,a.kt)("inlineCode",{parentName:"p"},"common/utility.h"),".\nLike Go's defer, it ensures the statement be executed before the function returns.\nIts implementation is based on the concept of ",(0,a.kt)("inlineCode",{parentName:"p"},"RAII"),"."),(0,a.kt)("h3",{id:"2-create-thread"},"2. Create thread"),(0,a.kt)("p",null,"There are many ways to create a thread. Just like the old ways you use ",(0,a.kt)("inlineCode",{parentName:"p"},"std::thread"),", but try ",(0,a.kt)("inlineCode",{parentName:"p"},"photon_std::thread")," instead."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Global function\nint func(int a, char* b) {}\n\n// Use global function to create a thread.\n// Will be automatically joined when thread object destructed, unless been detached.\nphoton_std::thread th(func, 1, '2');\nth.detach();\n\n// Create a thread with anonymous function (lambda)\nphoton_std::thread th([&] {\n    // Access variables directly in the context\n});\n\n// Create a thread with class member function\nclass A {\n    void f() {\n        new photon_std::thread(&A::g, this, 1, '2');\n    }\n    void g(int a, char* b) {}\n};\n")),(0,a.kt)("h3",{id:"3-concurrency"},"3. Concurrency"),(0,a.kt)("p",null,"A thread is basically a function, and thus an execution unit.\nYou can create multiple threads at a time to achieve concurrency, and wait them finished by Join."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"std::vector<photon_std::thread> threads;\nfor (int i = 0; i < 100; ++i) {\n    threads.emplace_back(func, 1, '2');\n}\nfor (auth& th : threads) {\n    th.join();\n}\n")),(0,a.kt)("h3",{id:"4-lock-and-synchronization"},"4. Lock and synchronization"),(0,a.kt)("p",null,"This is a typical ",(0,a.kt)("inlineCode",{parentName:"p"},"condition_variable")," usage. Again, we switch to Photon's exclusive namespace."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"bool condition = false;\nphoton_std::mutex mu;\nphoton_std::condition_variable cv;\n\n// Consumer thread\nphoton_std::thread([&]{\n    auto timeout = std::chrono::duration<std::chrono::seconds>(10);\n    photon_std::unique_lock<photon_std::mutex> lock(mu);\n    while (!condition) {\n        cv.wait(lock, timeout);\n    }\n}).detach();\n\n// Producer thread\nphoton_std::thread([&]{\n    photon_std::lock_guard<photon_std::mutex> lock(mu);\n    condition = true;\n    cv.notify_one();\n}).detach();\n")),(0,a.kt)("h3",{id:"5-file-io"},"5. File IO"),(0,a.kt)("p",null,"Photon has POSIX-like encapsulations for file and filesystem. In this example we first create a ",(0,a.kt)("inlineCode",{parentName:"p"},"IFileSystem")," under current working dir, and then open a ",(0,a.kt)("inlineCode",{parentName:"p"},"IFile")," from it. "),(0,a.kt)("p",null,"You can switch the io_engine from ",(0,a.kt)("inlineCode",{parentName:"p"},"photon::fs::ioengine_psync")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"photon::fs::ioengine_iouring"),",\nif your event_engine satisfied. io_uring IO is naturally asynchronous and non-blocking.\nIt can also use page cache compared with aio."),(0,a.kt)("p",null,"In addition to local file systems, Photon also supports a variety of remote file systems, such as httpfs, extfs, fusefs, etc."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <photon/fs/localfs.h>\n\nauto fs = photon::fs::new_localfs_adaptor(".", photon::fs::ioengine_psync);\nif (!fs) {\n    LOG_ERRNO_RETURN(0, -1, "failed to create fs");\n}\nDEFER(delete fs);\n\nauto file = fs->open("test-file", O_WRONLY | O_CREAT | O_TRUNC, 0644);\nif (!file) {\n    LOG_ERRNO_RETURN(0, -1, "failed to open file");\n}\nDEFER(delete file);\n\nssize_t n_written = file->write(buf, 4096);\n')),(0,a.kt)("p",null,"Both IFile and IFileSystem object will close itself at destruction. Again, RAII."),(0,a.kt)("h3",{id:"6-socket"},"6. Socket"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"tcp_socket_client")," + ",(0,a.kt)("inlineCode",{parentName:"p"},"tcp_socket_server")," is the most regular combination for client and server. Please refer to the API docs for more socket types."),(0,a.kt)("h4",{id:"client"},"Client"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <photon/net/socket.h>\n\nauto client = photon::net::new_tcp_socket_client();\nif (client == nullptr) {\n    LOG_ERRNO_RETURN(0, -1, "failed to create tcp client");\n}\nDEFER(delete client);\n\nphoton::net::EndPoint ep("127.0.0.1:9527");\nauto stream = client->connect(ep);\nif (!stream) {\n    LOG_ERRNO_RETURN(0, -1, "failed to connect server");\n}\nDEFER(delete stream);\n\n// Send data to socket\nchar buf[1024];\nif (stream->send(buf, 1024) != 1024) {\n    LOG_ERRNO_RETURN(0, -1, "failed to write socket");\n}\n')),(0,a.kt)("h4",{id:"server"},"Server"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <photon/net/socket.h>\n\nauto server = photon::net::new_tcp_socket_server();\nif (server == nullptr) {\n    LOG_ERRNO_RETURN(0, -1, "failed to create tcp server");\n}\nDEFER(delete server);\n\nauto handler = [&](photon::net::ISocketStream* stream) -> int {       \n    char buf[1024];\n    ssize_t ret = stream->recv(buf, 1024);\n    if (ret <= 0) {\n        LOG_ERRNO_RETURN(0, -1, "failed to read socket");\n    }     \n    return 0;\n};\n\nserver->set_handler(handler);\nserver->bind_v4localhost(9527);\nserver->listen();\n\nLOG_INFO("Server is listening for port ` ...", 9527);\nserver->start_loop(true);\n')),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"The stream is of type ",(0,a.kt)("inlineCode",{parentName:"p"},"photon::net::ISocketStream"),". It has extended write/read methods compared to traditional libc's send/recv."),(0,a.kt)("p",{parentName:"admonition"},"Essentially, write = fully_send, and read = fully_recv.")),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"LOG_INFO is Photon's unique logging system. It is based on template metaprogramming techniques\nand optimizes results at compile time. So runtime overhead is reduced.\nCompared with other logging systems based on ",(0,a.kt)("inlineCode",{parentName:"p"},"sprintf"),", Photon logging is 2~3 times faster than them."),(0,a.kt)("p",{parentName:"admonition"},"The ","`"," symbol is a generic placeholder for multiple types of elements.")),(0,a.kt)("h3",{id:"full-source-code"},"Full source code"),(0,a.kt)("p",null,"You may visit ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/alibaba/PhotonLibOS/blob/main/examples/simple/simple.cpp"},"https://github.com/alibaba/PhotonLibOS/blob/main/examples/simple/simple.cpp")," to get the source."),(0,a.kt)("p",null,"Or create your own CMake demo project guided by the ",(0,a.kt)("a",{parentName:"p",href:"/docs/introduction/how-to-integrate"},"How to integrate")," doc."))}u.isMDXComponent=!0}}]);